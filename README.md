# CS320_Portfolio
Project 1 /Project 2 Summary and Reflection

How can I ensure that my code, program, or software is functional and secure?

Ensuring code is functional and secure can be a confusing task. This was my first experence at Junit testing. I can ensure my code is secure and functional by adhering to the requirements and by writing tests that validate and check for invalidation which provide a high coverage percentage. I was able to achieve this in my program for by continously testing until all but one coverage percentages were at least 100%. One only being 93%. To make sure the code is functional primarily involved following the requirements and ensuring that it was secure involved writing tests based on requirements.

How do I interpret user needs and incorporate them into a program?

I tried to interpret user needs by first reading the requirements and  breaking them down into aspects that will or will not work with a program. The example that comes to mind is the constraints placed on maximum length and empty submissions. The first one was the names where they could not be null or not longer than 10 characters. I was able to read and incorporate the requirements into the program by using an condition statement which covered both of the failure options. This is a basic way of translating a need into a program because it takes the need directly into a conditional for success. There are more ambiguous requirements sometimes that take some extensive research. Another class required a program to be able to; on the push of a button, add time to two separate clocks. It was broken down very step-by-step into a program but not in this same way because of the general requirement and wasn't something as simple as creating an illegal argument exception.

How do I approach designing software? 

My approach to designing software could use some practice. I tend to take a look at the requirements documents or interview transcripts if that method is chosen, and create a checklist of requirements. These requirements I then, if applicable, break into a list of objects needed to accomplish this and then do the same for the methods needed. I begin writing the code to meet those requirements. Once the code is working, I will then go back over it and make it more efficient wherever I can. It has been a pretty effective method for me so far in my studies, but I could definitely use a more expansive approach and one that is more insightful.
